const fs = require('fs');
const path = require('path');
const { glob } = require('glob');
const { execSync } = require('child_process');

// Get Model ID from environment variables (Required)
const MODEL_ID = process.env.MODEL_ID;
if (!MODEL_ID) {
    console.error('‚ùå MODEL_ID environment variable is required');
    process.exit(1);
}

// Model-specific paths
const modelDataDir = `public/models/${MODEL_ID}`;
const modelPlaygroundDir = `src/app/models/${MODEL_ID}/playground`;

// Protected paths (common parts + other models' files)
const PROTECTED_PATHS = [
    'src/app/page.tsx',
    'src/app/layout.tsx',
    'src/app/models/*/page.tsx',        // Model landing pages
    'src/app/models/*/changelog/**',     // changelog pages
    'src/app/models/*/analytics/**',     // analytics pages
    'src/lib/**',
    'src/components/protected/**',
    'src/components/icons/**',
    'public/models/**/*.json',           // All model JSONs are protected
    'scripts/**',
    '.github/**',
    'Dockerfile',
    '.dockerignore',
    'cloudbuild.yaml',
    'next.config.ts',
    'package.json',
    'package-lock.json'
];

async function main() {
    console.log(`ü§ñ Starting AI Evolution for model: ${MODEL_ID} (via OpenRouter)...`);

    // 1. Get editable files list (only within this model's playground directory)
    const allFiles = await glob(`src/app/models/${MODEL_ID}/playground/**/*.{ts,tsx,css}`);
    const editableFiles = allFiles.filter(file =>
        !PROTECTED_PATHS.some(pattern => {
            const regex = new RegExp(pattern.replace('**', '.*').replace('*', '[^/]*'));
            return regex.test(file);
        })
    );

    console.log(`üìÅ Editable files for ${MODEL_ID}: ${editableFiles.length}`);

    // 2. Read model-specific analytics data
    const analyticsPath = path.join(modelDataDir, 'analytics.json');
    const analyticsPrevPath = path.join(modelDataDir, 'analytics-previous.json');

    let analytics = { pageviews: 0, revenue: '0.00', avgSessionDuration: 0, bounceRate: '0.0' };
    try {
        analytics = JSON.parse(fs.readFileSync(analyticsPath, 'utf-8'));
    } catch {
        console.log(`üìä No analytics found for ${MODEL_ID}, using defaults`);
    }

    // Backup previous day's data
    try {
        fs.copyFileSync(analyticsPath, analyticsPrevPath);
    } catch {
        console.log('üìä No previous analytics to backup');
    }

    // 3. Read model-specific changelog (past history)
    const changelogPath = path.join(modelDataDir, 'changelog.json');
    let changelog = [];
    try {
        changelog = JSON.parse(fs.readFileSync(changelogPath, 'utf-8'));
    } catch {
        console.log(`üìù No changelog found for ${MODEL_ID}, starting fresh`);
    }

    // 4. Read codebase
    const codebase = editableFiles.map(file => ({
        path: file,
        content: fs.readFileSync(file, 'utf-8')
    }));

    // 5. Build Prompt
    // 5. Read Prompt
    let prompt = '';
    const promptFile = process.env.PROMPT_FILE;

    if (promptFile && fs.existsSync(promptFile)) {
        console.log(`üìÑ Reading prompt from ${promptFile}`);
        prompt = fs.readFileSync(promptFile, 'utf-8');
    } else {
        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Éï„Ç°„Ç§„É´„Åå„Å™„ÅÑÂ†¥ÂêàÔºàËá™Âãï‰øÆÂæ©ÊôÇ„Å™„Å©Ôºâ„ÅØ„Ç∑„É≥„Éó„É´„Å´ÊßãÁØâ„Åô„Çã„Åã„Ç®„É©„Éº
        console.error('‚ùå PROMPT_FILE environment variable is required and must exist');
        process.exit(1);
    }

    // Add codebase info to prompt (if not included in template)
    // In Auto-Fix mode, better not to pass whole codebase but context helps.
    // It's expected to be controlled by Fix prompt.
    // Here we assume prompt is pre-replaced template, so execute as is.

    /* 
       NOTE: The prompt generated by generate-prompt.js does NOT include the codebase,
       so we must inject it here.
       generate-prompt.js only replaces {{ANALYTICS}} and {{CHANGELOG}}.
       Therefore, code injection happens here.
    */

    const codebaseContext = `
## Editable Codebase
${codebase.length > 0
            ? codebase.slice(0, 10).map(f => `### ${f.path}\n\`\`\`\n${f.content}\n\`\`\``).join('\n\n')
            : '(Empty Playground - Create new components)'
        }

${codebase.length > 10 ? `... and ${codebase.length - 10} more files` : ''}

## Protected Files (DO NOT TOUCH)
${PROTECTED_PATHS.join('\n')}
`;

    // If prompt file doesn't have codebase section, append it
    if (!prompt.includes('## Editable Codebase')) {
        prompt += '\n\n' + codebaseContext;
    }

    const model = process.env.OPENROUTER_MODEL || "anthropic/claude-3.7-sonnet";
    console.log(`üß† Calling OpenRouter API (${model}) for ${MODEL_ID}...`);

    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
            "Authorization": `Bearer ${process.env.ANTHROPIC_API_KEY}`,
            "HTTP-Referer": "https://self-evolving.dev",
            "X-Title": `Self-Evolving Website - ${MODEL_ID}`,
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            "model": model,
            "messages": [
                { "role": "user", "content": prompt }
            ],
            "max_tokens": 16000
        })
    });

    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`OpenRouter API Error: ${response.status} ${response.statusText} - ${errorText}`);
    }

    const data = await response.json();
    const resultText = data.choices[0].message.content;
    console.log('‚úÖ AI Response received');

    // 6. Parse and save response
    const result = parseAndSave(resultText);

    if (result.changes.length === 0) {
        console.log('‚ö†Ô∏è  No changes made');
        execSync(`echo "reasoning=No changes suggested" >> $GITHUB_OUTPUT`);
        execSync(`echo "files=" >> $GITHUB_OUTPUT`);
        process.exit(0);
    }

    // 7. Set GitHub Actions output
    execSync(`echo "reasoning=${result.reasoning}" >> $GITHUB_OUTPUT`);
    execSync(`echo "files=${result.files}" >> $GITHUB_OUTPUT`);
    execSync(`echo "model=${model}" >> $GITHUB_OUTPUT`);
    execSync(`echo "model_id=${MODEL_ID}" >> $GITHUB_OUTPUT`);

    console.log('‚ú® Changes applied successfully');
    console.log('üí° Reasoning:', result.reasoning);
    console.log('ü§ñ Model:', model);
    console.log('üÜî Model ID:', MODEL_ID);
    console.log('üìù Changed files:', result.files);
}

function parseAndSave(response) {
    const filePattern = /FILE:\s*(.+?)\n```[\w]*\n([\s\S]+?)\n```/g;
    const reasoningPattern = /REASONING:\s*(.+)/;
    const filesPattern = /FILES:\s*(.+)/;

    let match;
    const changes = [];

    while ((match = filePattern.exec(response)) !== null) {
        const [, filepath, content] = match;
        const trimmedPath = filepath.trim();

        // Check protected files
        if (PROTECTED_PATHS.some(pattern => {
            const regex = new RegExp(pattern.replace('**', '.*').replace('*', '[^/]*'));
            return regex.test(trimmedPath);
        })) {
            console.warn(`‚ö†Ô∏è  Skipping protected file: ${trimmedPath}`);
            continue;
        }

        // Restrict access to outside of model playground
        if (!trimmedPath.startsWith(`src/app/models/${MODEL_ID}/playground`)) {
            console.warn(`‚ö†Ô∏è  Skipping file outside model playground: ${trimmedPath}`);
            continue;
        }

        // Create directory (if needed)
        const dir = path.dirname(trimmedPath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(trimmedPath, content.trim());
        changes.push(trimmedPath);
        console.log(`‚úÖ Updated: ${trimmedPath}`);
    }

    const reasoningMatch = response.match(reasoningPattern);
    const reasoning = reasoningMatch ? reasoningMatch[1].trim() : 'No reasoning provided';

    const filesMatch = response.match(filesPattern);
    const files = filesMatch ? filesMatch[1].trim() : changes.join(',');

    return { reasoning, files, changes };
}

main().catch(error => {
    console.error('‚ùå Error:', error);
    process.exit(1);
});
